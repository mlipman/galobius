<!DOCTYPE html>
<html>
  <head>
    <title>Circle & Mobius Strip Visualization</title>
    <style>
      .container {
        display: flex;
        gap: 20px;
        padding: 20px;
      }
      canvas {
        border: 1px solid #000;
      }
      #threejs {
        border: 1px solid #000;
        width: 100%;
        height: 600px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="circleCanvas" width="300" height="300"></canvas>
      <canvas id="stripCanvas" width="300" height="200"></canvas>
    </div>
    <button id="lockButton" style="margin: 20px">Unlocked</button>
    <div id="values" style="padding: 20px"></div>
    <div id="threejs"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const circleCanvas = document.getElementById("circleCanvas");
      const stripCanvas = document.getElementById("stripCanvas");
      const ctxCircle = circleCanvas.getContext("2d");
      const ctxStrip = stripCanvas.getContext("2d");

      const circleCenter = {x: 150, y: 150};
      const circleRadius = 100;
      let theta1 = Math.PI;
      let theta2 = Math.PI;
      let dragging = null;
      let isLocked = false;

      function drawCircle() {
        ctxCircle.clearRect(0, 0, 300, 300);
        ctxCircle.beginPath();
        ctxCircle.arc(150, 150, 100, 0, Math.PI * 2);
        ctxCircle.stroke();

        const drawPoint = (angle) => {
          const x = 150 + 100 * Math.cos(angle);
          const y = 150 + 100 * Math.sin(angle);
          ctxCircle.beginPath();
          ctxCircle.arc(x, y, 10, 0, Math.PI * 2);
          ctxCircle.fill();
        };

        ctxCircle.fillStyle = "#f00";
        drawPoint(theta1);
        drawPoint(theta2);
      }

      /**
       * inputs are between 0 and 2pi. output u is 0 to 1. v is 0 to 24
       */
      function calculateUV(theat1, theta2) {
        const long1 = (theta1 / (2 * Math.PI)) * 24;
        const long2 = (theta2 / (2 * Math.PI)) * 24;
        const u = ((long1 + long2) % 24) / 24;

        const absDiff = Math.abs(long1 - long2);
        const k = Math.abs(12 - absDiff);

        const sumLessThan24 = long1 + long2 < 24;
        const diffLessThan12 = absDiff < 12;
        const opsAgree = sumLessThan24 == diffLessThan12;

        const v = opsAgree ? 12 - k : 12 + k;

        return {u, v};
        // const u = ((theta1 + theta2) % (2 * Math.PI)) / (2 * Math.PI);
        // const v = 1;

        // ///////////not working attempt from claude/////////////
        // // Normalize inputs to [0, 2π) range
        // theta1 = ((theta1 % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        // theta2 = ((theta2 % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

        // // Order the points to ensure continuity
        // let [t1, t2] = theta1 < theta2 ? [theta1, theta2] : [theta2, theta1];

        // // Calculate the shorter and longer arc lengths between points
        // let shortArc = t2 - t1;
        // let longArc = 2 * Math.PI - shortArc;

        // // Choose which arc to use based on which is shorter
        // let arcLength = Math.min(shortArc, longArc);
        // let useShortArc = shortArc <= longArc;

        // // For the Möbius strip, we need to handle the twist
        // // Map the arc midpoint to u coordinate (normalized to [0, 1))
        // let u = useShortArc
        //   ? ((t1 + arcLength / 2) / (2 * Math.PI)) % 1
        //   : ((t2 + arcLength / 2) / (2 * Math.PI)) % 1;

        // // Map the point separation to the v coordinate (scaled to [0, 24])
        // // When using the long arc, we need to flip the height to create the twist
        // let v = useShortArc
        //   ? (arcLength * 24) / (2 * Math.PI)
        //   : 24 - (arcLength * 24) / (2 * Math.PI);
        ///////////attempt from claude/////////////

        // to get v from theta 1 and 2
        // assume theta 1 and 2 are between 0 and 24
        // k is distnace from center.
        // if sum is .
        // examples
        /*
        k is abs(diff-12)
        sum 18/42:
        99-> v=0. diff0 k=12. 
        21/21->v=24
        15/3->v=12
        16/2-> diff 14. k=2
        14/4->diff 10 k=2

        00
        23/1 v=2. diff 22. k=10. v=12-k
        11/13 v=22. diff 2. k=10. v=12+k

        if the sum is at least 24
        */
      }

      // Add Three.js setup before the event handlers
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / 600,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, 600);
      document.getElementById("threejs").appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 5, -5).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      const mobiusStrip = createMobiusStrip();
      scene.add(mobiusStrip);

      const border = createMobiusStripBorder();
      scene.add(border);

      camera.position.set(1, 4, -4);
      camera.lookAt(0, 0, 0);

      function createMobiusStrip() {
        const segments = 100;
        const radius = 2;
        const width = 1;
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];

        for (let i = 0; i <= segments; i++) {
          const u = (i / segments) * Math.PI * 2;
          for (let j = 0; j <= 1; j++) {
            const v = j * 2 - 1;
            const x = (radius + width * v * Math.cos(u / 2)) * Math.cos(u);
            const y = (radius + width * v * Math.cos(u / 2)) * Math.sin(u);
            const z = width * v * Math.sin(u / 2);
            vertices.push(x, y, z);
          }
        }

        for (let i = 0; i < segments; i++) {
          const stride = i * 2;
          indices.push(stride, stride + 1, stride + 2);
          indices.push(stride + 1, stride + 2, stride + 3);
        }

        geometry.setIndex(indices);
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(vertices, 3)
        );

        const material = new THREE.MeshPhongMaterial({
          color: 0x00aaff,
          side: THREE.DoubleSide,
          flatShading: true,
          transparent: true,
          opacity: 0.8,
        });

        return new THREE.Mesh(geometry, material);
      }

      function createMobiusStripBorder() {
        const segments = 100;
        const radius = 2;
        const width = 1;
        const geometry = new THREE.BufferGeometry();
        const vertices = [];

        for (let i = 0; i <= segments; i++) {
          const u = (i / segments) * Math.PI * 2;
          const v = 1;
          const x = (radius + width * v * Math.cos(u / 2)) * Math.cos(u);
          const y = (radius + width * v * Math.cos(u / 2)) * Math.sin(u);
          const z = width * v * Math.sin(u / 2);
          vertices.push(x, y, z);
        }

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(vertices, 3)
        );

        const material = new THREE.LineBasicMaterial({color: 0xff0000});
        return new THREE.Line(geometry, material);
      }

      function updatePoint3D(u, v) {
        const normalizedV = (v - 12) / 12; // Convert v from [0,24] to [-1,1]
        const angle = u * Math.PI * 2;
        const radius = 2;
        const width = 1;

        const x =
          (radius + width * normalizedV * Math.cos(angle / 2)) *
          Math.cos(angle);
        const y =
          (radius + width * normalizedV * Math.cos(angle / 2)) *
          Math.sin(angle);
        const z = width * normalizedV * Math.sin(angle / 2);

        if (mobiusStrip.userData.point) {
          mobiusStrip.userData.point.position.set(x, y, z);
        } else {
          const pointGeometry = new THREE.SphereGeometry(0.1, 16, 16);
          const pointMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
          mobiusStrip.userData.point = new THREE.Mesh(
            pointGeometry,
            pointMaterial
          );
          mobiusStrip.userData.point.position.set(x, y, z);
          scene.add(mobiusStrip.userData.point);
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Modify the existing drawStrip function to also update the 3D point
      function drawStrip(u, v) {
        ctxStrip.clearRect(0, 0, 300, 200);

        // Draw mobius strip representation
        ctxStrip.strokeRect(0, 0, 300, 200);

        // Calculate coordinates with twist
        const x = u * 300;
        const y = 200 - (v * 200) / 24;
        ctxStrip.beginPath();
        ctxStrip.arc(x, y, 5, 0, Math.PI * 2);
        ctxStrip.fillStyle = "#00f";
        ctxStrip.fill();

        // Update the 3D point
        updatePoint3D(u, v);

        const lng1 = ((theta1 / (2 * Math.PI)) * 24).toFixed(0);
        const lng2 = ((theta2 / (2 * Math.PI)) * 24).toFixed(0);

        const absDiff = Math.abs(lng1 - lng2);
        const k = 12 - Math.abs(12 - absDiff);

        document.getElementById(
          "values"
        ).textContent = `lng1: ${lng1}, lng2: ${lng2}, k: ${k.toFixed(
          0
        )}, v: ${v.toFixed(0)}`;
      }

      // Start the animation loop
      animate();

      // Event handlers
      circleCanvas.addEventListener("mousedown", (e) => {
        const rect = circleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left - 150;
        const y = e.clientY - rect.top - 150;
        const dist1 = Math.hypot(
          x - 100 * Math.cos(theta1),
          y - 100 * Math.sin(theta1)
        );
        const dist2 = Math.hypot(
          x - 100 * Math.cos(theta2),
          y - 100 * Math.sin(theta2)
        );
        if (dist1 < 15) dragging = "theta1";
        if (dist2 < 15) dragging = "theta2";
      });

      function updateLockButton() {
        const button = document.getElementById("lockButton");
        button.textContent = isLocked ? "Locked" : "Unlocked";
        button.style.backgroundColor = isLocked
          ? "#2962ff"
          : "rgba(41, 98, 255, 0.3)";
        button.style.color = isLocked ? "white" : "#2962ff";
        button.style.padding = "8px 16px";
        button.style.border = "none";
        button.style.borderRadius = "4px";
        button.style.cursor = "pointer";
        button.style.width = "100px";
        button.style.textAlign = "center";
      }

      document.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const rect = circleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left - 150;
        const y = e.clientY - rect.top - 150;
        const angle = Math.atan2(y, x);

        if (isLocked) {
          // Calculate the angle difference
          const angleDiff = angle - (dragging === "theta1" ? theta1 : theta2);
          // Update both angles maintaining their relative positions
          theta1 = (theta1 + angleDiff + 2 * Math.PI) % (2 * Math.PI);
          theta2 = (theta2 + angleDiff + 2 * Math.PI) % (2 * Math.PI);
        } else {
          // Original behavior
          if (dragging === "theta1") theta1 = angle;
          else theta2 = angle;

          theta1 = (theta1 + 2 * Math.PI) % (2 * Math.PI);
          theta2 = (theta2 + 2 * Math.PI) % (2 * Math.PI);
        }

        const {u, v} = calculateUV(theta1, theta2);
        drawCircle();
        drawStrip(u, v);
      });

      document.addEventListener("mouseup", () => (dragging = null));

      // Add lock button event listener
      document.getElementById("lockButton").addEventListener("click", () => {
        isLocked = !isLocked;
        updateLockButton();
      });

      // Initial draw
      const {u, v} = calculateUV(theta1, theta2);
      drawCircle();
      drawStrip(u, v);
      updateLockButton();
    </script>
  </body>
</html>
